<!doctype html>
<html lang="en">
    <head>
        <title>stl viewer</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script src="three.js"></script>
        <script src="detector.js"></script>
        <script>

            var camera, scene, renderer,
            geometry, material, mesh, light1, scale, 
            offX, offY, offZ, manualRotate = false;

            function trim (str) {
                str = str.replace(/^\s+/, '');
                for (var i = str.length - 1; i >= 0; i--) {
                    if (/\S/.test(str.charAt(i))) {
                        str = str.substring(0, i + 1);
                        break;
                    }
                }
                return str;
            }

            // Notes:
            // - STL file format: http://en.wikipedia.org/wiki/STL_(file_format)
            // - 80 byte unused header
            // - All binary STLs are assumed to be little endian, as per wiki doc
            var parseStlBinary = function(stl) {
                var geo = new THREE.Geometry();
                var dv = new DataView(stl, 80); // 80 == unused header
                var isLittleEndian = true;
                var triangles = dv.getUint32(0, isLittleEndian); 

                // console.log('arraybuffer length:  ' + stl.byteLength);
                // console.log('number of triangles: ' + triangles);

                var offset = 4;
                var x = 0, y = 0, z = 0;
                maxX = minX = maxY = minY = maxZ = minZ = 0;
                for (var i = 0; i < triangles; i++) {
                    // Get the normal for this triangle
                    var normal = new THREE.Vector3(
                        dv.getFloat32(offset, isLittleEndian),
                        dv.getFloat32(offset+4, isLittleEndian),
                        dv.getFloat32(offset+8, isLittleEndian)
                    );
                    offset += 12;

                    // Get all 3 vertices for this triangle
                    for (var j = 0; j < 3; j++) {
                        geo.vertices.push(
                            new THREE.Vector3(
                                x=dv.getFloat32(offset, isLittleEndian),
                                y=dv.getFloat32(offset+4, isLittleEndian),
                                z=dv.getFloat32(offset+8, isLittleEndian)
                            )
                        );
                        maxX = Math.max(maxX, x);
                        minX = Math.min(minX, x);
                        maxY = Math.max(maxY, y);
                        minY = Math.min(minY, y);
                        maxZ = Math.max(maxZ, z);
                        minZ = Math.min(minZ, z);
                        offset += 12
                    }

                    // there's also a Uint16 "attribute byte count" that we
                    // don't need, it should always be zero.
                    offset += 2;   

                    // Create a new face for from the vertices and the normal             
                    geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
                }

                offX = (maxX - minX) / 2;
                offY = (maxY - minY) / 2;
                offZ = (maxZ - minZ) / 2;
                
                for(var i = 0; i < triangles * 3; ++i) {
                    geo.vertices[i].set(
                        geo.vertices[i].x - minX - offX, 
                        geo.vertices[i].y - minY - offY, 
                        geo.vertices[i].z - minZ - offZ
                    );
                }
                //geo.mergeVertices();
                //geo.computeFaceNormals();
                //geo.computeVertexNormals();
                
                mesh = new THREE.Mesh( 
                    geo,
                    /*new THREE.MeshNormalMaterial({
                        overdraw:true
                    }*/
                    /*new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        shading: THREE.SmoothShading
                    }*/
                    new THREE.MeshPhongMaterial({
                        color: 0xffffff, 
                        shading: THREE.SmoothShading, 
                        metal: true, 
                        shininess: 150
                    }
                ));
                //mesh.geometry.computeFaceNormals();
                scene.add(mesh);

                var mb = Math.max(maxX - minX, Math.max(maxY - minY, maxZ - minZ));

                if(mb != 0)
                    scale = 1. / mb;
                else
                    scale = 1;

                stl = null;
            };  

            var parseStl = function(stl) {
                var state = '';
                var lines = stl.split('\n');
                var geo = new THREE.Geometry();
                var name, parts, line, normal, done, vertices = [];
                var vCount = 0;
                stl = null;

                for (var len = lines.length, i = 0; i < len; i++) {
                    if (done) {
                        break;
                    }
                    line = trim(lines[i]);
                    parts = line.split(' ');
                    switch (state) {
                        case '':
                            if (parts[0] !== 'solid') {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "solid"');
                                return;
                            } else {
                                name = parts[1];
                                state = 'solid';
                            }
                            break;
                        case 'solid':
                            if (parts[0] !== 'facet' || parts[1] !== 'normal') {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "facet normal"');
                                return;
                            } else {
                                normal = [
                                    parseFloat(parts[2]), 
                                    parseFloat(parts[3]), 
                                    parseFloat(parts[4])
                                ];
                                state = 'facet normal';
                            }
                            break;
                        case 'facet normal':
                            if (parts[0] !== 'outer' || parts[1] !== 'loop') {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "outer loop"');
                                return;
                            } else {
                                state = 'vertex';
                            }
                            break;
                        case 'vertex': 
                            if (parts[0] === 'vertex') {
                                geo.vertices.push(new THREE.Vector3(
                                    parseFloat(parts[1]),
                                    parseFloat(parts[2]),
                                    parseFloat(parts[3])
                                ));
                            } else if (parts[0] === 'endloop') {
                                geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );
                                vCount++;
                                state = 'endloop';
                            } else {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');
                                return;
                            }
                            break;
                        case 'endloop':
                            if (parts[0] !== 'endfacet') {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "endfacet"');
                                return;
                            } else {
                                state = 'endfacet';
                            }
                            break;
                        case 'endfacet':
                            if (parts[0] === 'endsolid') {
                                //mesh = new THREE.Mesh( geo, new THREE.MeshNormalMaterial({overdraw:true}));
                                mesh = new THREE.Mesh( 
                                    geo, 
                                    new THREE.MeshLambertMaterial({
                                        overdraw:true,
                                        color: 0xaa0000,
                                        shading: THREE.FlatShading
                                    }
                                ));
                                scene.add(mesh);
                                done = true;
                            } else if (parts[0] === 'facet' && parts[1] === 'normal') {
                                normal = [
                                    parseFloat(parts[2]), 
                                    parseFloat(parts[3]), 
                                    parseFloat(parts[4])
                                ];
                                if (vCount % 1000 === 0) {
                                    console.log(normal);
                                }
                                state = 'facet normal';
                            } else {
                                console.error(line);
                                console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');
                                return;
                            }
                            break;
                        default:
                            console.error('Invalid state "' + state + '"');
                            break;
                    }
                }
            };

            

            init();
            animate();

            function init() {

                //Detector.addGetWebGLMessage();

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, .01, 100 );
                camera.position.z = 1;
                camera.position.y = 0;
                scene.add( camera );

                var directionalLight = new THREE.DirectionalLight( 0x888888 );
                directionalLight.position.x = 0; 
                directionalLight.position.y = 3; 
                directionalLight.position.z = 5; 
                directionalLight.position.normalize();
                scene.add( directionalLight );
                scene.add(new THREE.AmbientLight( 0x404040 ));

                var xhr = new XMLHttpRequest();
                xhr.onload = function (ev) {
                    var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
                    parseStlBinary(rep);
                    //parseStl(xhr.responseText);
                    mesh.rotation.x = 5;
                    mesh.rotation.z = 3;
                    mesh.scale.set(scale, scale, scale);
                    console.log('done parsing');
                }
                xhr.onerror = function(e) {
                    console.log(e);
                }
                
                xhr.open( "GET", 'stls/' + window.location.search.substring(1) + '.stl', true );
                xhr.responseType = "arraybuffer";
                //xhr.setRequestHeader("Accept","text/plain");
                //xhr.setRequestHeader("Content-Type","text/plain");
                //xhr.setRequestHeader('charset', 'x-user-defined');
                xhr.send( );

                renderer = new THREE.WebGLRenderer(); //new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                document.body.appendChild( renderer.domElement );

                var mousedown = false, mousepos = [0, 0];
                renderer.domElement.addEventListener('mousedown', function(evt) {
                    mousepos = [evt.clientX, evt.clientY];
                    mousedown = true;
                });
                renderer.domElement.addEventListener('mouseup', function(evt) {
                    mousedown = false;
                });
                renderer.domElement.addEventListener('mousemove', function(evt) {
                    if(mousedown === false)
                        return;

                    curMove = [evt.clientX - mousepos[0], evt.clientY - mousepos[1]];
                    mousepos = [evt.clientX, evt.clientY];
                    manualRotate = true;
                    mesh.rotation.z += curMove[0] * .01;
                    mesh.rotation.x += curMove[1] * .01;
                });
                renderer.domElement.addEventListener('mousewheel', function(evt) {
                    camera.position.z -= evt.wheelDelta * .001;
                    evt.preventDefault();
                });
            }

            function animate() {

                // note: three.js includes requestAnimationFrame shim
                requestAnimationFrame( animate );
                render();

            }

            function render() {

                //mesh.rotation.x += 0.01;
                if (mesh && !manualRotate) {
                    mesh.rotation.z += 0.0075;
                }
                //light1.position.z -= 1;

                renderer.render( scene, camera );

            }

        </script>
    </body>
</html>